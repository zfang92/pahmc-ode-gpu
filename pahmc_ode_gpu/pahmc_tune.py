# -*- coding: utf-8 -*-
"""
@author: Zheng Fang

This is where everything is put togegher. It receives all the user-provided 
specs from 'main.py' as well as the data generated by 'data_preparation.py' (or 
by the user if working with real experimental data), and perform the PAHMC 
algorithm for state and parameter estimations. The dynamics model is defined in
'cuda_lib_dynamics.py' or in 'def_dynamics.py', other necessary CUDA kernels 
are defined in 'cuda_utilities.py', and the gradient descent functionality is 
implemented in 'gd.py'.
"""


from pathlib import Path
import time

from numba import cuda, jit
import numpy as np

from pahmc_ode_gpu.gd import descend
from pahmc_ode_gpu.cuda_utilities import k__action, k__diff, k__dAdX, \
    k__dAdpar, k__leapfrog_X, k__leapfrog_par, k__linearop2d, k__linearop1d, \
    k__zeros1d


def anneal(k__field, k__jacobian, k__dfield_dpar, stimuli, Y, 
           D, M, obsdim, dt, Rf0, alpha, betamax, 
           n_iter, epsilon, S, mass, scaling, 
           soft_dynrange, par_start, name, tune_beta, Rm=1.0, burn=0.5):
    """
    This is the master function that brings the PAHMC algorithm into one piece.

    Inputs
    ------
          k__field: CUDA kernel.
       k__jacobian: CUDA kernel.
    k__dfield_dpar: CUDA kernel.
           stimuli: D-by-M numpy array of floats.
                 Y: len(obsdim)-by-M numpy array of floats.
                 D: integer.
                 M: integer.
            obsdim: 1d (shapeless) numpy array of integers.
                dt: float.
               Rf0: 1d (shapeless) numpy array of floats, with length D.
             alpha: float.
           betamax: integer.
            n_iter: 1d (shapeless) numpy array of integers, with length 
                    betamax.
           epsilon: 1d (shapeless) numpy array of floats, with length betamax.
                 S: 1d (shapeless) numpy array of integers, with length 
                    betamax.
              mass: betamax-by-3 numpy array of floats.
           scaling: 1d (shapeless) numpy array of floats, with length betamax.
     soft_dynrange: D-by-2 numpy array of floats.
         par_start: 1d (shapeless) numpy array.
              name: the name of the dynamical system.
         tune_beta: the current beta value that is undergoing stepwise tuning.
                Rm: float.
              burn: float. Note that this is the proportion of HMC samples that
                    are thrown away in each beta, which is different from the 
                    'burndata' switch.

    Returns
    ------
                 Rm: float.
               burn: float.
                 Rf: betamax-by-D numpy array of floats.
            eta_avg: 1d (shapeless) numpy array of floats, with length betamax.
         acceptance: 1d (shapeless) numpy array of floats, with length betamax.
             action: betamax-by-(max(n_iter)+2) numpy array of floats.
    action_meanpath: 1d (shapeless) numpy array of floats, with length betamax.
        ME_meanpath: 1d (shapeless) numpy array of floats, with length betamax.
        FE_meanpath: 1d (shapeless) numpy array of floats, with length betamax.
             X_init: betamax-by-D-by-M numpy array of floats.
               X_gd: betamax-by-D-by-M numpy array of floats.
             X_mean: betamax-by-D-by-M numpy array of floats.
        par_history: betamax-by-(max(n_iter)+2)-by-len(par_start) numpy array 
                     of floats.
           par_mean: betamax-by-len(par_start) numpy array of floats.
     Xfinal_history: betamax-by-(max(n_iter)+2)-by-D numpy array of floats.
    """
    # create some utility variables
    Rf = Rf0 * (alpha ** np.arange(betamax))[:, np.newaxis]

    unobsdim = np.int64(np.setdiff1d(np.arange(D), obsdim))
    obs_ind = -np.ones(D, dtype='int64')
    for l in range(len(obsdim)):
        obs_ind[obsdim[l]] = l

    mass_X = np.zeros((betamax,D,M))
    mass_par = np.zeros((betamax,len(par_start)))
    for beta in range(betamax):
        mass_X[beta, obsdim, :] = mass[beta, 0]
        mass_X[beta, unobsdim, :] = mass[beta, 1]
        mass_par[beta, :] = mass[beta, 2]

    # initialize the remaining output variables
    eta_avg = np.zeros(betamax)
    acceptance = np.zeros(betamax)
    action = np.zeros((betamax,np.max(n_iter)+2))
    action_meanpath = np.zeros(betamax)
    ME_meanpath = np.zeros(betamax)
    FE_meanpath = np.zeros(betamax)
    X_init = np.zeros((betamax,D,M))
    X_gd = np.zeros((betamax,D,M))
    X_mean = np.zeros((betamax,D,M))
    par_history = np.zeros((betamax,np.max(n_iter)+2,len(par_start)))
    par_mean = np.zeros((betamax,len(par_start)))
    Xfinal_history = np.zeros((betamax,np.max(n_iter)+2,D))

    # bring static variables to GPU
    d_stimuli = cuda.to_device(stimuli)
    d_Y = cuda.to_device(Y)
    d_obsdim = cuda.to_device(obsdim)
    d_obs_ind = cuda.to_device(obs_ind)

    # initialize device arrays that will be used as outputs for the kernels
    d_field = cuda.device_array((D,M))
    d_jacobian = cuda.device_array((D,D,M))
    d_dfield_dpar = cuda.device_array((D,len(par_start),M))
    d_diff = cuda.device_array((D,M-1))
    d_dAdX = cuda.device_array((D,M))
    d_dAdpar = cuda.device_array((len(par_start),))
    d_action = cuda.device_array((1,))

    # stepwise tuning===========================================================
    if tune_beta == 0:
        # perform dynamic initialization, i.e., initialize X and par for beta=0
        X_init[0, :, 0] \
          = np.random.uniform(soft_dynrange[:, 0], soft_dynrange[:, 1], (D,))
        X_init[0, obsdim, 0] = Y[:, 0]

        d_par_start = cuda.to_device(par_start)
        d_field_m = cuda.device_array((D,1))

        for m in range(M-1):
            d_X_m = cuda.to_device(X_init[0][:, [m]])
            d_stimuli_m = cuda.to_device(stimuli[:, [m]])

            k__field[(16,32), (2,128)](d_X_m, d_par_start, d_stimuli_m, 
                                       d_field_m)
            F = dt / 2 * d_field_m.copy_to_host()

            d_X_m = cuda.to_device(X_init[0][:, [m]]+F)

            k__field[(16,32), (2,128)](d_X_m, d_par_start, d_stimuli_m, 
                                       d_field_m)
            X_init[0][:, [m+1]] \
              = X_init[0][:, [m]] + dt * d_field_m.copy_to_host()
            X_init[0, obsdim, m+1] = Y[:, m+1]

        par_history[0, 0, :] = par_start
    else:
        # extract results from the previous beta
        file \
          = np.load(Path.cwd()/'user_results'/f'tune_{name}_{tune_beta-1}.npz')
        X_init = file['X_mean']
        par_history[0, 0, :] = file['par_mean'][0, :]
        file.close()
    #===========================================================================

    # do PAHMC
    for beta in range(betamax):
        print('-------------------------------------------------------------')
        print(f'beta = {beta}:\n')

        # initialize device arrays specific to current beta
        d_Rf_beta = cuda.to_device(Rf[beta, :])
        d_mass_X_beta = cuda.to_device(mass_X[beta, :, :])
        d_mass_par_beta = cuda.to_device(mass_par[beta, :])

        # initialize action and Xfinal_history (2 out of 4) for current beta
        d_X_init_beta = cuda.to_device(X_init[beta, :, :])
        d_par_init_beta = cuda.to_device(par_history[beta, 0, :])
        k__field[(16,32), (2,128)](d_X_init_beta, d_par_init_beta, d_stimuli, 
                                   d_field)
        k__zeros1d[40, 256](d_action)
        cuda.synchronize()
        k__action[(16,32), (16,16)](d_X_init_beta, d_field, d_Rf_beta, d_Y, dt, 
                                    d_obsdim, Rm, d_action)
        action[beta, 0] = d_action.copy_to_host()[0]

        Xfinal_history[beta, 0, :] = X_init[beta, :, -1]

        # exploration - gradient descent
        X_gd[beta, :, :], par_history[beta, 1, :], action[beta, 1], eta \
          = descend(k__field, k__jacobian, k__dfield_dpar, 
                    X_init[beta, :, :], par_history[beta, 0, :], Rf[beta, :], 
                    d_stimuli, d_Y, dt, d_obsdim, d_obs_ind, Rm)

        eta_avg[beta] = np.mean(eta)
        Xfinal_history[beta, 1, :] = X_gd[beta, :, -1]

        # exploitation - Hamiltonian Monte Carlo
        t0 = time.perf_counter()
        errcount = 0
        printflag = 0

        X0 = X_gd[beta, :, :]
        par0 = par_history[beta, 1, :]

        for n in range(2, n_iter[beta]+2):
            print(f'\r  Performing calculations... (step={n-1})', end='')

            # call HMC
            X, par, action[beta, n], accept, errflag \
              = hmc(X0, par0, action[beta, n-1], 
                    beta, d_Rf_beta, d_mass_X_beta, d_mass_par_beta, 
                    D, M, dt, obsdim, unobsdim, Rm, 
                    epsilon, S, mass, scaling, mass_X, mass_par, 
                    k__field, k__jacobian, k__dfield_dpar, 
                    d_stimuli, d_Y, d_obsdim, d_obs_ind, 
                    d_field, d_jacobian, d_dfield_dpar, 
                    d_diff, d_dAdX, d_dAdpar, d_action)

            X0 = X
            par0 = par

            # sanity check
            if errflag == 1:
                errcount += 1
                if errcount == 5 and printflag == 0:
                    print('\n  WARNING: got bad values when performing '
                          +'leapfrog simulations!')
                    printflag = 1
            else:
                errcount = 0

            # keep results
            acceptance[beta] += accept

            if n - 1 > burn * n_iter[beta]:
                X_mean[beta, :, :] += X
                par_mean[beta, :] += par

            Xfinal_history[beta, n, :] = X[:, -1]
            par_history[beta, n, :] = par

        print(f'\r  Performing calculations... '
              +f'finished in {time.perf_counter()-t0:.2f} seconds;\n')

        # finalize acceptance rate and mean path for current beta
        acceptance[beta] /= n_iter[beta]

        X_mean[beta, :, :] /= np.ceil((1-burn)*n_iter[beta])
        par_mean[beta, :] /= np.ceil((1-burn)*n_iter[beta])

        # calculate action, measurement and model errors from mean path
        d_X_mean_beta = cuda.to_device(X_mean[beta, :, :])
        d_par_mean_beta = cuda.to_device(par_mean[beta, :])
        k__field[(16,32), (2,128)](d_X_mean_beta, d_par_mean_beta, d_stimuli, 
                                   d_field)
        k__zeros1d[40, 256](d_action)
        cuda.synchronize()
        k__action[(16,32), (16,16)](d_X_mean_beta, d_field, d_Rf_beta, d_Y, dt, 
                                    d_obsdim, Rm, d_action)
        action_meanpath[beta] = d_action.copy_to_host()[0]

        ME_meanpath[beta] = Rm / 2 / M * np.sum((X_mean[beta, obsdim, :]-Y)**2)

        field_mean = d_field.copy_to_host()
        fX_mean = X_mean[beta, :, :M-1] \
                  + dt / 2 * (field_mean[:, 1:] + field_mean[:, :M-1])
        FE_meanpath[beta] \
          = np.sum(Rf[beta, :]/2/M\
                   *np.sum((X_mean[beta, :, 1:]-fX_mean)**2, axis=1))

        # print action_meanpath and FE_meanpath for current beta
        print(f'       action (mean path) = {action_meanpath[beta]};')
        print(f'  model error (mean path) = {FE_meanpath[beta]}.\n')

        # initialize X and par (2 out of 4) for next beta
        if beta != betamax - 1:
            X_init[beta+1, :, :] = X_mean[beta, :, :]
            par_history[beta+1, 0, :] = par_mean[beta, :]

    return burn, Rm, Rf, eta_avg, acceptance, \
           action, action_meanpath, ME_meanpath, FE_meanpath, \
           X_init, X_gd, X_mean, par_history, par_mean, Xfinal_history

def hmc(X0, par0, action0, 
        beta, d_Rf_beta, d_mass_X_beta, d_mass_par_beta, 
        D, M, dt, obsdim, unobsdim, Rm, 
        epsilon, S, mass, scaling, mass_X, mass_par, 
        k__field, k__jacobian, k__dfield_dpar, 
        d_stimuli, d_Y, d_obsdim, d_obs_ind, 
        d_field, d_jacobian, d_dfield_dpar, 
        d_diff, d_dAdX, d_dAdpar, d_action):
    """
    This function generates one HMC proposal per call.

    Inputs
    ------
                 X0: D-by-M numpy array of floats.
               par0: 1d (shapeless) numpy array of floats.
            action0: float.
               beta: integer.
          d_Rf_beta: 1d (shapeless) device array of floats, with length D.
      d_mass_X_beta: D-by-M device array of floats.
    d_mass_par_beta: 1d (shapeless) device array of floats, with length 
                     len(par0).
                ...
           unobsdim: 1d (shapeless) numpy array of integers.
                ...
             mass_X: betamax-by-D-by-M numpy array of floats.
           mass_par: betamax-by-len(par0) array of floats.
                ...
          d_stimuli: D-by-M device array of floats.
                d_Y: len(obsdim)-by-M device array of floats.
           d_obsdim: 1d (shapeless) device array of floats.
          d_obs_ind: 1d (shapeless) device array of floats, with length D.
            d_field: D-by-M device array of floats.
         d_jacobian: D-by-D-by-M device array of floats.
      d_dfield_dpar: D-by-len(par0)-by-M device array of floats.
             d_diff: D-by-(M-1) deivce array of floats.
             d_dAdX: D-by-M device array of floats.
           d_dAdpar: 1d (shapeless) device array of floats, with length 
                     len(par0).
           d_action: 1d (shapeless) device array of float, with length 1.

    Returns
    ------
          X: D-by-M numpy array of floats.
        par: 1d (shapeless) numpy array of floats.
     action: float.
     accept: integer.
    errflag: integer.
    """
    # generate initial momenta
    pX0, ppar0 = pre_process(beta, D, M, obsdim, unobsdim, mass, len(par0))

    # bring phase space variables to GPU
    d_X = cuda.to_device(X0)
    d_par = cuda.to_device(par0)

    d_pX = cuda.to_device(pX0)
    d_ppar = cuda.to_device(ppar0)

    # initialze candidate action
    k__zeros1d[40, 256](d_action)

    # Hamiltonian dynamics - half step for momenta
    k__field[(16,32), (2,128)](d_X, d_par, d_stimuli, d_field)
    cuda.synchronize()
    k__diff[(32,16), (2,128)](d_X, d_field, dt, d_diff)
    k__jacobian[(4,4,32), (2,2,64)](d_X, d_par, d_jacobian)
    k__dfield_dpar[(4,4,32), (2,2,64)](d_X, d_par, d_dfield_dpar)
    k__zeros1d[40, 256](d_dAdpar)
    cuda.synchronize()
    k__dAdX[(32,16), (2,128)](d_X, d_diff, d_jacobian, d_Rf_beta, 
                              scaling[beta], d_Y, dt, d_obsdim, 
                              d_obs_ind, Rm, d_dAdX)
    k__dAdpar[(4,4,32), (2,2,64)](d_X, d_diff, d_dfield_dpar, 
                                  d_Rf_beta, scaling[beta], dt, d_dAdpar)
    cuda.synchronize()

    k__linearop2d[(32,16), (2,128)](d_pX, -epsilon[beta]/2, d_dAdX, d_pX)
    k__linearop1d[40, 256](d_ppar, -epsilon[beta]/2, d_dAdpar, d_ppar)
    cuda.synchronize()

    # Hamiltonian dynamics - full steps for X, par, and momenta
    for i in range(S[beta]):
        # full step for X, par
        k__leapfrog_X[(32,16), (2,128)](d_pX, epsilon[beta], d_mass_X_beta, d_X)
        k__leapfrog_par[40, 256](d_ppar, epsilon[beta], d_mass_par_beta, d_par)
        cuda.synchronize()

        # full step for momenta except at the end of trajectory
        k__field[(16,32), (2,128)](d_X, d_par, d_stimuli, d_field)
        cuda.synchronize()
        k__diff[(32,16), (2,128)](d_X, d_field, dt, d_diff)
        k__jacobian[(4,4,32), (2,2,64)](d_X, d_par, d_jacobian)
        k__dfield_dpar[(4,4,32), (2,2,64)](d_X, d_par, d_dfield_dpar)
        k__zeros1d[40, 256](d_dAdpar)
        cuda.synchronize()
        k__dAdX[(32,16), (2,128)](d_X, d_diff, d_jacobian, d_Rf_beta, 
                                  scaling[beta], d_Y, dt, d_obsdim, 
                                  d_obs_ind, Rm, d_dAdX)
        k__dAdpar[(4,4,32), (2,2,64)](d_X, d_diff, d_dfield_dpar, 
                                      d_Rf_beta, scaling[beta], dt, d_dAdpar)
        cuda.synchronize()

        if i != S[beta] - 1:
            k__linearop2d[(32,16), (2,128)](d_pX, -epsilon[beta], d_dAdX, d_pX)
            k__linearop1d[40, 256](d_ppar, -epsilon[beta], d_dAdpar, d_ppar)
            cuda.synchronize()

    # Hamiltonian dynamics - half step for momenta
    k__linearop2d[(32,16), (2,128)](d_pX, -epsilon[beta]/2, d_dAdX, d_pX)
    k__linearop1d[40, 256](d_ppar, -epsilon[beta]/2, d_dAdpar, d_ppar)
    cuda.synchronize()

    # bring momenta back to CPU
    pX = d_pX.copy_to_host()
    ppar = d_ppar.copy_to_host()

    # get candidate action
    k__action[(16,32), (16,16)](d_X, d_field, d_Rf_beta, d_Y, dt, d_obsdim, Rm, 
                                d_action)
    action_cand = d_action.copy_to_host()[0]

    # calculate change in Hamiltonian
    dH = post_process(pX0, ppar0, pX, ppar, action0, action_cand, beta, 
                      D, M, mass_X, mass_par, scaling)

    # check for numerical issues
    if np.isnan(action_cand) == False and np.isinf(action_cand) == False \
      and np.isnan(dH) == False:
        errflag = 0
    else:
        errflag = 1

    # Metropolis-Hastings acceptance rule
    if np.random.rand() < np.exp(dH):
        X = d_X.copy_to_host()
        par = d_par.copy_to_host()
        action = action_cand
        accept = 1
    else:
        X = X0
        par = par0
        action = action0
        accept = 0

    return X, par, action, accept, errflag

@jit(nopython=True)
def pre_process(beta, D, M, obsdim, unobsdim, mass, len_par):
    """
    Generate initial momenta for HMC.

    Inputs
    ------
        ...
    len_par: integer.

    Returns
    ------
      pX0: D-by-M numpy array of floats.
    ppar0: 1d (shapeless) numpy array of floats.
    """
    pX0 = np.zeros((D,M))
    ppar0 = np.zeros(len_par)

    std_obs = np.sqrt(mass[beta, 0])
    std_unobs = np.sqrt(mass[beta, 1])
    std_par = np.sqrt(mass[beta, 2])
    
    for a in range(len(obsdim)):
        for m in range(M):
            pX0[obsdim[a], m] = np.random.normal(0, std_obs)
    
    for a in range(len(unobsdim)):
        for m in range(M):
            pX0[unobsdim[a], m] = np.random.normal(0, std_unobs)

    for b in range(len_par):
        ppar0[b] = np.random.normal(0, std_par)

    return pX0, ppar0

@jit(nopython=True)
def post_process(pX0, ppar0, pX, ppar, action0, action_cand, beta, 
                 D, M, mass_X, mass_par, scaling):
    """
    Calculate the change in the Hamiltonian.

    Inputs
    ------
            pX0: D-by-M numpy array of floats.
          ppar0: 1d (shapeless) numpy array of floats, with length len(par).
             pX: D-by-M numpy array of floats.
           ppar: 1d (shapeless) numpy array of floats, with length len(par).
        action0: float.
    action_cand: float.
            ...

    Returns
    ------
    dH: float.
    """
    dH = 0.0

    for a in range(D):
        for m in range(M):
            dH += (pX0[a, m] ** 2 - pX[a, m] ** 2) / (2 * mass_X[beta, a, m])

    for b in range(len(ppar0)):
        dH += (ppar0[b] ** 2 - ppar[b] ** 2) / (2 * mass_par[beta, b])

    dH = dH / scaling[beta] + (action0 - action_cand)

    return dH

